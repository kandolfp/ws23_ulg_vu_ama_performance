<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/ws23_ulg_vu_ama_performance/libs/highlight/github.min.css">
   
    <script src="/ws23_ulg_vu_ama_performance/libs/clipboard.min.js"></script>
  
  
  <script src="/ws23_ulg_vu_ama_performance/libs/plotly-1_58_5.min.js"></script> 
  <script>
    // This function is used when calling `\fig{...}` See # Using \fig{...} below
    const PlotlyJS_json = async (div, url) => {
      response = await fetch(url); // get file
      fig = await response.json(); // convert it to json
      // Make the plot fit the screen responsively. See the documentation of plotly.js. https://plotly.com/javascript/responsive-fluid-layout/
      if (typeof fig.config === 'undefined') { fig["config"]={} }
      delete fig.layout.width
      delete fig.layout.height
      fig["layout"]["autosize"] = true
      fig["config"]["autosizable"] = true
      fig["config"]["responsive"] = true

      // make it easier to scroll throught the website rather than being blocked by a figure.
      fig.config["scrollZoom"] = false

      // PlotlyJS.savefig by default add the some more attribute to make a static plot.
      // Disable them to make the website fancier.
      delete fig.config.staticPlot
      delete fig.config.displayModeBar
      delete fig.config.doubleClick
      delete fig.config.showTips

      Plotly.newPlot(div, fig);
    };
  </script>
  
  <link rel="stylesheet" href="/ws23_ulg_vu_ama_performance/css/jtd.css">
<link rel="stylesheet" href="/ws23_ulg_vu_ama_performance/css/extras.css">
<link rel="icon" href="/ws23_ulg_vu_ama_performance/assets/favicon.ico">

<style>
  /* #148 wrap long header */
  .franklin-content a.header-anchor,
  .franklin-toc li a
   {
    word-wrap: break-word;
    white-space: normal;
  }
</style>

   <title>Remote Computing - High Performance Computing - Usage</title>  
</head>
<body>                      <!-- closed in foot.html -->
<div class="page-wrap">   <!-- closed in foot.html -->
  <!-- SIDE BAR -->
  <div class="side-bar">
    <div class="header">
      <a href="/ws23_ulg_vu_ama_performance/" class="title">
        Julia
      </a>
    </div>
    <label for="show-menu" class="show-menu">MENU</label>
    <input type="checkbox" id="show-menu" role="button">
    <div class="menu" id="side-menu">
      <ul class="menu-list">
        <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/" class="menu-list-link ">Start</a>
        <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/" class="menu-list-link ">Parallel computing</a>
          <ul class="menu-list-child-list ">
            <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/performance/" class="menu-list-link ">Measuring performance</a>
            <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/simd/" class="menu-list-link ">Single Instruction Multiple Data</a>
            <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/pi/" class="menu-list-link ">&pi; example</a>
            <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/multithreading/" class="menu-list-link ">Multithreading</a>
            <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/distributed/" class="menu-list-link ">Distributed computing</a>
            <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/gpu/" class="menu-list-link ">GPU computing</a>
          </ul>
          <li class="menu-list-item active"><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/" class="menu-list-link active">Remote computing</a>
            <ul class="menu-list-child-list ">
              <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/history" class="menu-list-link ">History</a>
              <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/hpc/" class="menu-list-link active">High Performance Computing</a>
              <ul class="menu-list-child-list ">
                <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/hpc/basics" class="menu-list-link ">Basics</a>
                <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/hpc/architecture" class="menu-list-link ">Architecture</a>
                <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/hpc/usage" class="menu-list-link active">Usage</a>
              </ul>
              <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/cloud/" class="menu-list-link ">Cloud Computing</a>
                <ul class="menu-list-child-list ">
                  <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/cloud/basics" class="menu-list-link ">Basics</a>
                  <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/cloud/architecture" class="menu-list-link ">Architecture</a>
                  <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/cloud/setup_vhpc" class="menu-list-link ">Setup vHPC</a>
                </ul>
              <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/notes/" class="menu-list-link ">Notes</a>
            </ul>
      </ul>
    </div>
    <div class="footer">
      This is <em>Just the docs</em>, adapted from the <a href="https://github.com/pmarsceill/just-the-docs" target="_blank">Jekyll theme</a>.
    </div>
  </div>
  <!-- CONTENT -->
  <div class="main-content-wrap"> <!-- closed in foot.html -->
    <div class="main-content">    <!-- closed in foot.html -->
      <div class="main-header">
        WS23 971007 VU Advanced Methods and its Applications - Performance topics
      </div>



<!-- Content appended here (in class franklin-content) -->
<div class="franklin-content"><h1 id="usage"><a href="#usage" class="header-anchor">Usage</a></h1>
<div class="franklin-toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#testsetup">Testsetup</a></li><li><a href="#slurm_-_as_a_job_scheduler">Slurm - as a job scheduler</a><ol><li><a href="#submitting_a_job">Submitting a job</a></li><li><a href="#running_parallel_jobs">Running parallel jobs</a></li><li><a href="#interactive_jobs">Interactive jobs</a></li><li><a href="#monitoring">Monitoring</a></li><li><a href="#altering_jobs">Altering jobs</a></li><li><a href="#deleting_jobs">Deleting jobs</a></li></ol></li><li><a href="#answers_to_the_questions">Answers to the questions</a></li></ol></div>
<h2 id="overview"><a href="#overview" class="header-anchor">Overview</a></h2>
<p>The idea of HPC Systems is to be used as much as possible, usually by a lot of different people or programs.  In order to make sure that users and programs do not interfere with each other the nodes can not be accessed directly.  The actual execution of programs is done by a job scheduler.  We need to define a job, with all the resources we need and hand this job over to the job scheduler.  The job scheduler will now make sure that all constraints are met and schedule our job along with all the other jobs.</p>
<p>While there is a lot of work going into making the access and use of such systems easier, more convenient, more interactive and maybe even provide some graphical user interface, the standard mode of access is still via terminal<sup id="fnref:1"><a href="#fndef:1" class="fnref">[1]</a></sup>. </p>
<p>Via <code>ssh</code> we usually reach one of the login nodes and from here we get access to the job scheduler. We can prepare our job script, maybe compile some sources, sort out data and when everything is finished submit our job to the queue &#40;and wait&#41;. </p>
<p>There are different job schedulers around, the most commonly found is <a href="https://www.schedmd.com/">Slurm</a>.  The <em>workload manager</em> itself is <a href="https://github.com/SchedMD/slurm">open source</a>, the company SchedMD® <em>distributes and maintains the canonical version of Slurm as well as providing Slurm support, development, training, installation, and configuration</em><sup id="fnref:2"><a href="#fndef:2" class="fnref">[2]</a></sup>.</p>
<h2 id="testsetup"><a href="#testsetup" class="header-anchor">Testsetup</a></h2>
<p>If you do this class at home or at another time you can still use a test setup.  E.g. use the excellent docker-compose setup of <a href="https://github.com/giovtorres">Giocanni Torres</a> that you can find <a href="https://github.com/giovtorres/slurm-docker-cluster">here</a>.</p>
<p>At the time of creation of these notes the following sequence of commands will start a cluster and give you access to the nodes. </p>
<pre><code class="bash hljs">SLURM_TAG=slurm-22-05-10-1 IMAGE_TAG=22.05.10.1 docker-compose build
SLURM_TAG=slurm-22-05-10-1 IMAGE_TAG=22.05.10.1 docker-compose up -d
docker <span class="hljs-built_in">exec</span> -it slurmctld bash</code></pre>
<p>For the live session of this class we created a virtual HPC with 3 nodes.  How this was done is described further in the cloud section. </p>
<div class="important">How to get access to the live setup is not in the notes.</div>
<h2 id="slurm_-_as_a_job_scheduler"><a href="#slurm_-_as_a_job_scheduler" class="header-anchor">Slurm - as a job scheduler</a></h2>
<p>The inner workings of the Slurm can be found in the <a href="https://slurm.schedmd.com/">documentation</a>, we discuss some of the most important commands<sup id="fnref:3"><a href="#fndef:3" class="fnref">[3]</a></sup></p>
<ul>
<li><p><code>sbatch</code> is used so submit a job script </p>
</li>
<li><p><code>srun</code> is used to submit a job for execution in real time</p>
</li>
<li><p><code>scancel</code> is used to cancel a pending or running job or job step</p>
</li>
<li><p><code>squeue</code> reports the state of jobs or job steps</p>
</li>
<li><p><code>sacct</code> is used to report job or job step accounting information about active or completed jobs</p>
</li>
<li><p><code>scontrol</code> is the administrative tool used to view and/or modify jobs or the Slurm state</p>
</li>
</ul>
<p>Let us dive right in and submit our first job and from there we extend our job to be more refined.</p>
<div class="note"><div class="title">⚠ Note</div>
<div class="content">The next part is designed as a type along section.      We also ask some questions in between to keep your focus, the <a href="#answers_to_the_questions">answers</a> are at the bottom of the page.</div></div>
<div class="note"><div class="title">⚠ Note</div>
<div class="content">The following notes are a combination from various sources <sup id="fnref:3"><a href="#fndef:3" class="fnref">[3]</a></sup> <sup id="fnref:4"><a href="#fndef:4" class="fnref">[4]</a></sup>.</div></div>
<h3 id="submitting_a_job"><a href="#submitting_a_job" class="header-anchor">Submitting a job</a></h3>
<p>Let us start by directly handing over a job to Slurm</p>
<pre><code class="bash hljs">$ sbatch --wrap=<span class="hljs-string">&quot;sleep 100s &amp;&amp; /bin/hostname&quot;</span>
Submitted batch job 1</code></pre>
<p>the <code>--wrap</code> option allows us to wrap a command string into a shell script and submit this script to the job scheduler. </p>
<p><strong>Question 1</strong>: What does the command <code>sleep 10s &amp;&amp; /bin/hostname</code> do? </p>
<p>Slurm keeps track of the <em>standard output</em> and <em>error output</em> of the command executed and redirects them into an output file.  By default this file is called <code>slurm-n.out</code> where <code>n</code> corresponds to the <code>JobID</code> &#40;<code>1</code> in the example above&#41;. </p>
<pre><code class="bash hljs">$ <span class="hljs-built_in">cat</span> slurm-1.out
c1</code></pre>
<p>This job takes a while to complete, in order to see the status of our currently scheduled jobs we use <code>squeue</code>:</p>
<pre><code class="bash hljs">$ squeue 
JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)
    1    normal     wrap     root  R       0:01      1 c1</code></pre>
<p>With a couple of options we can see more details about the job, e.g. <code>--start</code> will tell us the expected start time and with <code>--user&#61;user_name</code> we can limit the output to just our users.</p>
<p>Now that we have submitted a first job we can have a look how to do this in a more orderly fashion.  The general format of the <code>sbatch</code> command is</p>
<pre><code class="bash hljs">sbatch [OPTIONS(0)...] [ : [OPTIONS(N)...]] script(0) [args(0)...]</code></pre>
<p>where the important part here is <code>script</code>.  Let us transfer and extend the previous job into a job script <code>job.slurm</code> and add some of the long list of <code>sbatch</code> <a href="https://slurm.schedmd.com/sbatch.html">options</a></p>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment">#SBATCH --job-name=peter</span>
<span class="hljs-comment">#SBATCH --ntasks=1</span>
<span class="hljs-comment">#SBATCH --cpus-per-task=1</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;running on `/bin/hostname`&quot;</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> {1..10}
<span class="hljs-keyword">do</span>
    <span class="hljs-built_in">sleep</span> 1
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>
<span class="hljs-keyword">done</span></code></pre>
<p>Note that the lines starting with <code>#SBATCH</code> are comments for the shell script but will be parsed by <code>sbatch</code>.  We can submit the job and check in the queue</p>
<pre><code class="bash hljs">$ sbatch job.slurm
Submitted batch job 2

$ squeue
JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)
    2    normal    peter     root  R       0:03      1 c1</code></pre>
<p>Of course it is possible to have options in the job file and provide them during the call in the command line.  In this case, the ones provide to the command line will have precedence and this can be used to override our default settings. </p>
<p>We are not running on a production cluster but of course it is always a good idea to limit the resources that we use as much as possible. In our case we know how long the job runs so let us include this information.</p>
<button type="button" class="collapsible" style="background-color:#b5ddff"> Exercise </button><div class="collapsiblecontent">  Have a look at the <code>sbatch</code> options and provide a maximal &#40;wallclock&#41; time for the job, e.g. 1 minute. </p>
<p>What happens if this time is shorter than the runtime of our job?</p>
<p><div class="solution"> Solution </div><div class="solutioncollapsible">  We just show how to include this via a command line argument</p>
<pre><code class="bash hljs">sbatch --time=0:1 job.slurm</code></pre>
<p>If the time is smaller than the actual execution time, the job is killed before it finishes. </p>
<p>You can check this with </p>
<pre><code class="bash hljs">$ sacct
JobID           JobName  Partition    Account  AllocCPUS      State ExitCode
------------ ---------- ---------- ---------- ---------- ---------- -------- 
1                 wrap      normal       root          1  COMPLETED      0:0 
1.batch           batch                  root          1  COMPLETED      0:0 
2                 peter     normal       root          1  COMPLETED      0:0 
2.batch           batch                  root          1  COMPLETED      0:0 
3                 peter     normal       root          1    TIMEOUT      0:0 
3.batch           batch                  root          1  CANCELLED     0:15</code></pre>
<p></div> </div>
<p>By specifying <code>--ntasks&#61;1</code> we only requested one task, lets extend this to two and also try the <code>--verbose</code> option to see if the actual variable is overwritten.</p>
<pre><code class="bash hljs">$ sbatch --ntasks=2 --verbose job.slurm 
sbatch: defined options
sbatch: -------------------- --------------------
sbatch: cpus-per-task       : 1
sbatch: job-name            : peter
sbatch: ntasks              : 2
sbatch: verbose             : 1
sbatch: -------------------- --------------------
sbatch: end of defined options
sbatch: <span class="hljs-keyword">select</span>/linear: init: Linear node selection plugin loaded with argument 17
sbatch: <span class="hljs-keyword">select</span>/cons_res: common_init: <span class="hljs-keyword">select</span>/cons_res loaded
sbatch: <span class="hljs-keyword">select</span>/cray_aries: init: Cray/Aries node selection plugin loaded
sbatch: <span class="hljs-keyword">select</span>/cons_tres: common_init: <span class="hljs-keyword">select</span>/cons_tres loaded
Submitted batch job 4

$ squeue 
JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)
   4     normal    peter     root  R       0:08      2 c[1-2]</code></pre>
<p>and the corresponding output is</p>
<pre><code class="bash hljs">$ <span class="hljs-built_in">cat</span> <span class="hljs-built_in">cat</span> slurm-4.out 
running on c1
1
2
3
4
5
6
7
8
9
10</code></pre>
<p><strong>Question 2</strong>: If the job is run on both nodes, why do we only see <code>c1</code> as output?</p>
<button type="button" class="collapsible" style="background-color:#b5ddff"> Exercise </button><div class="collapsiblecontent">  Now we could also use <code>--cpus-per-task&#61;2</code> to allocate two CPUs.</p>
<p>Try this and explain the result.</p>
<p><div class="solution"> Solution </div><div class="solutioncollapsible">  The following will execute the job with one task but two CPUs</p>
<pre><code class="bash hljs">$ sbatch --cpus-per-task=2 --verbose job.slurm 
sbatch: error: CPU count per node can not be satisfied
sbatch: error: Batch job submission failed: Requested node configuration is not available</code></pre>
<p>As our test cluster only supports one CPU per node. Slurm is not able to schedule this task and therefore we get the error. </div> </div>
<p>As we can see it might happen, that our job can not be submitted or that we have an error in the setup.  In order to check if the job is correct, we can use the <code>--test-only</code> option</p>
<pre><code class="bash hljs">$ sbatch --test-only job.slurm
sbatch: Job 5 to start at 2023-11-09T17:49:30 using 1 processors on nodes c1 <span class="hljs-keyword">in</span> partition normal

$ sbatch --cpus-per-task=2 --test-only job.slurm
allocation failure: Requested node configuration is not available</code></pre>
<p>On success Slurm will tell us when to job is probably starting &#40;to the best of its knowledge&#41; and where.  If it is not successful we see why. </p>
<h3 id="running_parallel_jobs"><a href="#running_parallel_jobs" class="header-anchor">Running parallel jobs</a></h3>
<p>Slurm provides the <code>srun</code> command to execute parallel jobs. The command will do the resource allocation and launch of the task implicitly.</p>
<pre><code class="bash hljs">$ srun --nodes=2 --label /bin/hostname
1: c2
0: c1</code></pre>
<p>Here <code>--nodes&#61;2</code> allocated two nodes and <code>--label</code> includes the task number for the output.</p>
<p>As we have seen before, we can define multiple tasks in <code>sbatch</code> and that is the recommended way. Therefore, running a parallel job consists of two phases:</p>
<ol>
<li><p>Starting the job script on the main node selected by the job scheduler. In Slurm terms this is the actual job.</p>
</li>
<li><p>Deploy the individual <em>tasks</em> across all of the nodes selected by the job scheduler. In Slurm terms this is called the <em>job step</em>. One job might have several job steps. </p>
</li>
</ol>
<button type="button" class="collapsible" style="background-color:#b5ddff"> Exercise </button><div class="collapsiblecontent">  Rewrite our <code>job.slum</code> for two tasks and such that the actual workload is distributed with <code>srun</code>.</p>
<p><div class="solution"> Solution </div><div class="solutioncollapsible">  We need to split up the code and put the <code>echo</code> and the <code>for</code> loop into a separate script, i.e. <code>task.sh</code>.</p>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;running on `/bin/hostname`&quot;</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> {1..10}
<span class="hljs-keyword">do</span>
    <span class="hljs-built_in">sleep</span> 1
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$i</span>
<span class="hljs-keyword">done</span></code></pre>
<p>and with this we can rewrite <code>job.slurm</code> as</p>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment">#SBATCH --job-name=peter</span>
<span class="hljs-comment">#SBATCH --ntasks=1</span>
<span class="hljs-comment">#SBATCH --cpus-per-task=1</span>

srun --label ./task.sh</code></pre>
<p>Do not forget to make <code>task.sh</code> executable by calling <code>chmod &#43;x task.sh</code>.</p>
<pre><code class="bash hljs">$ sbatch --ntasks=2 job.slurm
Submitted batch job 5

$ squeue 
JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)
    5    normal    peter     root  R       0:02      2 c[1-2]
 <span class="hljs-built_in">cat</span> slurm-5.out 
0: running on c1
1: running on c2
0: 1
1: 1
0: 2
1: 2
0: 3
1: 3
0: 4
1: 4
0: 5
1: 5
0: 6
1: 6
0: 7
1: 7
0: 8
1: 8
0: 9
1: 9
0: 10
1: 10</code></pre>
<p></div> </div>
<p><strong>Question 3</strong>: Why does the job see the file <code>task.sh</code> on every node?</p>
<h3 id="interactive_jobs"><a href="#interactive_jobs" class="header-anchor">Interactive jobs</a></h3>
<p>With <code>srun</code> we can also start <em>interactive jobs</em>.  This gives us access to a node by still obeying to the job scheduler. </p>
<pre><code class="bash hljs">[root@slurmctld data]<span class="hljs-comment"># srun --pty bash</span>
[root@c1 data]<span class="hljs-comment"># /bin/hostname</span>
c1
[root@c1 data]<span class="hljs-comment"># exit</span>
<span class="hljs-built_in">exit</span>
[root@slurmctld data]<span class="hljs-comment">#</span></code></pre>
<p>Note how the prompt changes.  For the advanced users, with <code>--x11</code> you can also forward the DISPLAY and have e.g. a new <code>xterm</code> window.</p>
<h3 id="monitoring"><a href="#monitoring" class="header-anchor">Monitoring</a></h3>
<p>We have already seen how to use <code>squeue</code> to list all running or waiting jobs.  There are a couple of options that extend the table, like </p>
<ul>
<li><p><code>--start</code> to display the estimated start time &#40;you might always start earlier&#41;</p>
</li>
<li><p><code>--name&#61;job_name&#40;s&#41;</code> for a comma separated list of job names</p>
</li>
<li><p><code>--user&#61;user_name&#40;s&#41;</code> for a comma separated list of user names</p>
</li>
</ul>
<div class="important">In particular we can use <code>squeue</code> to look up our <code>JobID</code> that is needed for a lot of the following commands.</div>
<p>In order to get information about past jobs we can use <code>sacct</code> or <code>sacct -X</code> to skip the information about the individual job steps.</p>
<pre><code class="bash hljs">sacct -X
JobID           JobName  Partition    Account  AllocCPUS      State ExitCode 
------------ ---------- ---------- ---------- ---------- ---------- -------- 
1              hostname     normal       root          2  COMPLETED      0:0 
2              hostname     normal       root          2  COMPLETED      0:0 
3                 peter     normal       root          1    TIMEOUT     13:0 
4                 peter     normal       root          1  COMPLETED      0:0 
5                 peter     normal       root          1  COMPLETED      0:0 
6                 peter     normal       root          1     FAILED      1:0 
7                 peter     normal       root          2  COMPLETED      0:0 
8                  bash     normal       root          1  COMPLETED      0:0</code></pre>
<h3 id="altering_jobs"><a href="#altering_jobs" class="header-anchor">Altering jobs</a></h3>
<p>While our job is in a <em>pending</em> state we can change its configuration.  This is done via <code>scontrol</code> so for example we can change the maximal runtime with</p>
<pre><code class="bash hljs">scontrol update job JobID TimeLimit=2</code></pre>
<h3 id="deleting_jobs"><a href="#deleting_jobs" class="header-anchor">Deleting jobs</a></h3>
<p>To delete jobs we use <code>scancel</code> together with the <code>JobID</code>. We can actually delete multiple jobs with one call of <code>scancel</code>:</p>
<pre><code class="bash hljs">scancel 6</code></pre>
<h2 id="answers_to_the_questions"><a href="#answers_to_the_questions" class="header-anchor">Answers to the questions</a></h2>
<ol>
<li><p>The command <code>sleep 10s &amp;&amp; /bin/hostname</code> first sleeps for 10 seconds, afterwards it will output the node &#40;what we usually see in the prompt&#41; where the job is started.</p>
</li>
<li><p>Our job only runs on one CPU, therefore it only runs on one of the nodes.</p>
</li>
<li><p>The directory is shared over all the nodes. Recall the previous section about shared filesystems, <a href="../architecture#storage">link</a>. </p>
</li>
</ol>
<p><table class="fndef" id="fndef:1">
    <tr>
        <td class="fndef-backref"><a href="#fnref:1">[1]</a></td>
        <td class="fndef-content">The standard Operating System is Linux, there are some UNIX clusters but Windows is not the way to go here.</td>
    </tr>
</table>
 <table class="fndef" id="fndef:2">
    <tr>
        <td class="fndef-backref"><a href="#fnref:2">[2]</a></td>
        <td class="fndef-content"><a href="https://www.schedmd.com/index.php">www.schedmd.com</a></td>
    </tr>
</table>
 <table class="fndef" id="fndef:3">
    <tr>
        <td class="fndef-backref"><a href="#fnref:3">[3]</a></td>
        <td class="fndef-content"><a href="https://slurm.schedmd.com/quickstart.html">Quickstart</a> the commands section</td>
    </tr>
</table>
 <table class="fndef" id="fndef:4">
    <tr>
        <td class="fndef-backref"><a href="#fnref:4">[4]</a></td>
        <td class="fndef-content"><a href="https://www.uibk.ac.at/zid/systeme/hpc-systeme/common/tutorials/slurm-tutorial.html">UIBK LEO5 Tutorial</a></td>
    </tr>
</table>
</p>
<div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> - <a href="https://ehrensperger.dev/">Gregor Ehrensperger</a>, <a href="https://orcid.org/0000-0003-3601-0852">Peter Kandolf</a>. Last modified: November 16, 2023.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    </div> <!-- end of class main-content -->
    </div> <!-- end of class main-content-wrap -->
    </div> <!-- end of class page-wrap-->
    
    
      


      <script>
    (function(){
    
      // Get the elements.
      // - the 'pre' element.
      // - the 'div' with the 'paste-content' id.
    
      var pre = document.getElementsByTagName('pre');
    
      // Add a copy button in the 'pre' element.
      // which only has the className of 'language-'.
    
      for (var i = 0; i < pre.length; i++) {
        var isLanguage = pre[i].children[0].tagName == 'CODE';
    
        if ( isLanguage ) {
          var button           = document.createElement('button');
              button.className = 'copy-button';
              button.textContent = 'Copy';
    
              pre[i].appendChild(button);
        }
      };
    
      // Run Clipboard
    
      var copyCode = new Clipboard('.copy-button', {
        target: function(trigger) {
          return trigger.previousElementSibling;
        }
      });
    
      // On success:
      // - Change the "Copy" text to "Copied".
      // - Swap it to "Copy" in 2s.
      // - Lead user to the "contenteditable" area with Velocity scroll.
    
      copyCode.on('success', function(event) {
        event.clearSelection();
        event.trigger.textContent = 'Copied';
        window.setTimeout(function() {
          event.trigger.textContent = 'Copy';
        }, 2000);
    
      });
    
      // On error (Safari):
      // - Change the  "Press Ctrl+C to copy"
      // - Swap it to "Copy" in 2s.
    
      copyCode.on('error', function(event) {
        event.trigger.textContent = 'Press "Ctrl + C" to copy';
        window.setTimeout(function() {
          event.trigger.textContent = 'Copy';
        }, 5000);
      });
    
    })();
</script>
    
  </body>
</html>

<script>
  var coll = document.getElementsByClassName("collapsible");
  var i;

  for (i = 0; i < coll.length; i++) {
    coll[i].addEventListener("click", function() {
      this.classList.toggle("active");
      var content = this.nextElementSibling;
      if (content.style.display === "block") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
    });
  }
</script>

<script>
  var coll = document.getElementsByClassName("solutioncollapsible");
  var sols = document.getElementsByClassName("solution");
  
  const queryString = window.location.search;
  const urlParams = new URLSearchParams(queryString);
  const myVar = urlParams.get('solution')

  if ( myVar == 'true') {
    for (i = 0; i < coll.length; i++) {
      coll[i].style.display = "block";
    }

    for (i = 0; i < sols.length; i++) {
      sols[i].style.display = "block";
    }
  }
</script>