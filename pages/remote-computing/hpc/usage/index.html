<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/ws23_ulg_vu_ama_performance/libs/highlight/github.min.css">
   
    <script src="/ws23_ulg_vu_ama_performance/libs/clipboard.min.js"></script>
  
  
  <script src="/ws23_ulg_vu_ama_performance/libs/plotly-1_58_5.min.js"></script> 
  <script>
    // This function is used when calling `\fig{...}` See # Using \fig{...} below
    const PlotlyJS_json = async (div, url) => {
      response = await fetch(url); // get file
      fig = await response.json(); // convert it to json
      // Make the plot fit the screen responsively. See the documentation of plotly.js. https://plotly.com/javascript/responsive-fluid-layout/
      if (typeof fig.config === 'undefined') { fig["config"]={} }
      delete fig.layout.width
      delete fig.layout.height
      fig["layout"]["autosize"] = true
      fig["config"]["autosizable"] = true
      fig["config"]["responsive"] = true

      // make it easier to scroll throught the website rather than being blocked by a figure.
      fig.config["scrollZoom"] = false

      // PlotlyJS.savefig by default add the some more attribute to make a static plot.
      // Disable them to make the website fancier.
      delete fig.config.staticPlot
      delete fig.config.displayModeBar
      delete fig.config.doubleClick
      delete fig.config.showTips

      Plotly.newPlot(div, fig);
    };
  </script>
  
  <link rel="stylesheet" href="/ws23_ulg_vu_ama_performance/css/jtd.css">
<link rel="stylesheet" href="/ws23_ulg_vu_ama_performance/css/extras.css">
<link rel="icon" href="/ws23_ulg_vu_ama_performance/assets/favicon.ico">

<style>
  /* #148 wrap long header */
  .franklin-content a.header-anchor,
  .franklin-toc li a
   {
    word-wrap: break-word;
    white-space: normal;
  }
</style>

   <title>Remote Computing - High Performance Computing - Usage</title>  
</head>
<body>                      <!-- closed in foot.html -->
<div class="page-wrap">   <!-- closed in foot.html -->
  <!-- SIDE BAR -->
  <div class="side-bar">
    <div class="header">
      <a href="/ws23_ulg_vu_ama_performance/" class="title">
        Julia
      </a>
    </div>
    <label for="show-menu" class="show-menu">MENU</label>
    <input type="checkbox" id="show-menu" role="button">
    <div class="menu" id="side-menu">
      <ul class="menu-list">
        <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/" class="menu-list-link ">Start</a>
        <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/" class="menu-list-link ">Parallel computing</a>
          <ul class="menu-list-child-list ">
            <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/performance/" class="menu-list-link ">Measuring performance</a>
            <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/simd/" class="menu-list-link ">Single Instruction Multiple Data</a>
            <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/pi/" class="menu-list-link ">&pi; example</a>
            <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/multithreading/" class="menu-list-link ">Multithreading</a>
            <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/distributed/" class="menu-list-link ">Distributed computing</a>
            <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/hpc/gpu/" class="menu-list-link ">GPU computing</a>
          </ul>
          <li class="menu-list-item active"><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/" class="menu-list-link active">Remote computing</a>
            <ul class="menu-list-child-list ">
              <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/history" class="menu-list-link ">History</a>
              <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/hpc/" class="menu-list-link active">High Performance Computing</a>
              <ul class="menu-list-child-list ">
                <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/hpc/basics" class="menu-list-link ">Basics</a>
                <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/hpc/architecture" class="menu-list-link ">Architecture</a>
                <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/hpc/usage" class="menu-list-link active">Usage</a>
              </ul>
              <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/cloud/" class="menu-list-link ">Cloud Computing</a>
              <li class="menu-list-item "><a href="/ws23_ulg_vu_ama_performance/pages/remote-computing/notes/" class="menu-list-link ">Notes</a>
            </ul>
      </ul>
    </div>
    <div class="footer">
      This is <em>Just the docs</em>, adapted from the <a href="https://github.com/pmarsceill/just-the-docs" target="_blank">Jekyll theme</a>.
    </div>
  </div>
  <!-- CONTENT -->
  <div class="main-content-wrap"> <!-- closed in foot.html -->
    <div class="main-content">    <!-- closed in foot.html -->
      <div class="main-header">
        WS23 971007 VU Advanced Methods and its Applications - Performance topics
      </div>



<!-- Content appended here (in class franklin-content) -->
<div class="franklin-content"><h1 id="usage"><a href="#usage" class="header-anchor">Usage</a></h1>
<div class="franklin-toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#slurm_-_as_a_job_scheduler">Slurm - as a job scheduler</a><ol><li><a href="#submitting_a_job">Submitting a job</a></li><li><a href="#running_parallel_jobs">Running parallel jobs</a></li></ol></li><li><a href="#answers_to_the_questions">Answers to the questions</a></li></ol></div>
<h2 id="overview"><a href="#overview" class="header-anchor">Overview</a></h2>
<p>As we can imagine, the idea of HPC Systems is to be used as much as possible, usually by a lot of different people.  In order to make sure that we do not interfere with each others&#39; processes &#40;unless wanted&#41; the nodes can not be accessed directly.  The actual execution of programs is done by a job scheduler.  We need to define a job, with all the resources we need and hand this job over to the job scheduler.  The job scheduler will now make sure that all constraints are met and schedule our job along with all the other jobs according to some metric.</p>
<p>While there is a lot of work going into making the access and use of such systems easier, more convenient, more interactive and maybe even provide some graphical user interface, the standard way is via terminal<sup id="fnref:1"><a href="#fndef:1" class="fnref">[1]</a></sup>. </p>
<p>So via <code>ssh</code> we usually reach one of the login nodes and from here we get access to the job scheduler. We can prepare our job script, maybe compile some sources, sort out data and when everything is finished queue our job. </p>
<p>While there are different job schedulers around, the most commonly found one is <a href="https://www.schedmd.com/">Slurm</a>.  The <em>workload manager</em> itself is <a href="https://github.com/SchedMD/slurm">open source</a>, the company SchedMD® <em>distributes and maintains the canonical version of Slurm as well as providing Slurm support, development, training, installation, and configuration</em><sup id="fnref:2"><a href="#fndef:2" class="fnref">[2]</a></sup>.</p>
<h2 id="slurm_-_as_a_job_scheduler"><a href="#slurm_-_as_a_job_scheduler" class="header-anchor">Slurm - as a job scheduler</a></h2>
<div class="important"><p>HAVE A CLUSTER ON ONE OF THE WORKSTATIONS OR DOCKER-COMPOSE</p>
<p>Describe the setup</p></div>
<p>The inner working of the Slurm can be found in the <a href="https://slurm.schedmd.com/">documentation</a>. The most important commands to know are<sup id="fnref:3"><a href="#fndef:3" class="fnref">[3]</a></sup></p>
<ul>
<li><p><code>sbatch</code> is used so submit a job script </p>
</li>
<li><p><code>srun</code> is used to submit a job for execution in real time</p>
</li>
<li><p><code>scancel</code> is used to cancel a pending or running job or job step.</p>
</li>
<li><p><code>squeue</code> reports the state of jobs or job steps.</p>
</li>
<li><p><code>sacct</code> is used to report job or job step accounting information about active or completed jobs.</p>
</li>
<li><p><code>scontrol</code> is the administrative tool used to view and/or modify Slurm state.</p>
</li>
</ul>
<div class="note"><div class="title">⚠ Note</div>
<div class="content">The following notes are a combination from various sources <sup id="fnref:3"><a href="#fndef:3" class="fnref">[3]</a></sup> <sup id="fnref:4"><a href="#fndef:4" class="fnref">[4]</a></sup></div></div>
<p>Let us dive right in and submit our first job and from there we extend our job to be more refined.</p>
<div class="note"><div class="title">⚠ Note</div>
<div class="content">The next parts are designed as a type along session.      We also ask some questions in between to keep your focus, the <a href="#answers_to_the_questions">answers</a> are at the bottom of the page.</div></div>
<h3 id="submitting_a_job"><a href="#submitting_a_job" class="header-anchor">Submitting a job</a></h3>
<p>Let us start by directly handing over a job to slurm</p>
<pre><code class="bash hljs">$ sbatch --wrap=<span class="hljs-string">&quot;sleep 10s &amp;&amp; /bin/hostname&quot;</span>
Submitted batch job 1</code></pre>
<p>the <code>--wrap</code> option allows us to wrap a command string in a shell script and submit it. </p>
<p><strong>Question 1</strong>: What does the command <code>sleep 10s &amp;&amp; /bin/hostname</code> do? </p>
<p>Slurm keeps track of the standard and error output of the command executed and this is stored into an output file.  By default this file is called <code>slurm-n.out</code> where <code>n</code> corresponds to the job number. </p>
<pre><code class="bash hljs">$ <span class="hljs-built_in">cat</span> slurm-1.out
c1</code></pre>
<p>This job takes a while to complete, in order to see the status of our currently scheduled jobs we use <code>squeue</code>:</p>
<pre><code class="bash hljs">$ squeue 
JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)
    1    normal     wrap     root  R       0:01      1 c1</code></pre>
<p>With a couple of options we can see more details about the job, e.g. <code>--start</code> will tell us the expected start time and with <code>--user&#61;user_name</code> we can limit the output to just our users.</p>
<p>Now that we have submitted a first job we can have a look how to do this in a more orderly fashion.  The general format of the <code>sbatch</code> command is</p>
<pre><code class="bash hljs">sbatch [OPTIONS(0)...] [ : [OPTIONS(N)...]] script(0) [args(0)...]</code></pre>
<p>where the important part her is <code>script</code>.  Let us transfer and extend the previous job into a job script <code>job.slurm</code> and add some of the long list of <code>sbatch</code> <a href="https://slurm.schedmd.com/sbatch.html">options</a></p>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment">#SBATCH --job-name=peter</span>
<span class="hljs-comment">#SBATCH --ntasks=1</span>
<span class="hljs-comment">#SBATCH --cpus-per-task=1</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;running on `/bin/hostname`&quot;</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> {1..10}
<span class="hljs-keyword">do</span>
    <span class="hljs-built_in">sleep</span> 1
    <span class="hljs-built_in">echo</span> i
<span class="hljs-keyword">done</span></code></pre>
<p>Note that the lines starting with <code>#SBATCH</code> are comments for the shell script but will be parsed by <code>sbatch</code>.  We can submit the job and watch in the queue</p>
<pre><code class="bash hljs">$ sbatch job.slurm
Submitted batch job 2
$ squeue
JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)
    2    normal    peter     root  R       0:03      1 c1</code></pre>
<p>Now of course it is possible to have options in the job file and provide them during the call of <code>sbatch</code>.  In this case, the ones provide to the command line will have precedence and this can be used to override your default settings. </p>
<p>Now we not running on a production cluster but of course it is always a good idea to limit the resources that you use as much as possible. In our case we know how long the job runs so let us include this information.</p>
<button type="button" class="collapsible" style="background-color:#b5ddff"> Exercise </button><div class="collapsiblecontent">  Have a look at the <code>sbatch</code> options and provide a maximal &#40;wallclock&#41; time for the job, e.g. 11 seconds. </p>
<p>What happens if this time is shorter than the runtime of our job?</p>
<p><strong>Important</strong>: for some reason on the test cluster you can not specify seconds, so change the example from above to sleep for <code>10</code> seconds and work with one minute. </p>
<p><div class="solution"> Solution </div><div class="solutioncollapsible">  We just show how to include this via a command line argument.</p>
<pre><code class="bash hljs">sbatch --time=0:1 job.slurm</code></pre>
<p>If the time is smaller than the actual execution time, the job is killed before it finishes. </p>
<p>You can check this with </p>
<pre><code class="bash hljs">$ sacct
JobID           JobName  Partition    Account  AllocCPUS      State ExitCode
------------ ---------- ---------- ---------- ---------- ---------- -------- 
1                 wrap      normal       root          1  COMPLETED      0:0 
1.batch           batch                  root          1  COMPLETED      0:0 
2                 peter     normal       root          1  COMPLETED      0:0 
2.batch           batch                  root          1  COMPLETED      0:0 
3                 peter     normal       root          1    TIMEOUT      0:0 
3.batch           batch                  root          1  CANCELLED     0:15</code></pre>
<p></div> </div>
<p>By specifying <code>--ntasks&#61;1</code> we only requested one CPU, lets extend this to two and also try the <code>--verbose</code> option to see if the actual variable is overwritten.</p>
<pre><code class="bash hljs">$ sbatch --ntasks=2 --verbose job.slurm 
sbatch: defined options
sbatch: -------------------- --------------------
sbatch: cpus-per-task       : 1
sbatch: job-name            : peter
sbatch: ntasks              : 2
sbatch: verbose             : 1
sbatch: -------------------- --------------------
sbatch: end of defined options
sbatch: <span class="hljs-keyword">select</span>/linear: init: Linear node selection plugin loaded with argument 17
sbatch: <span class="hljs-keyword">select</span>/cons_res: common_init: <span class="hljs-keyword">select</span>/cons_res loaded
sbatch: <span class="hljs-keyword">select</span>/cray_aries: init: Cray/Aries node selection plugin loaded
sbatch: <span class="hljs-keyword">select</span>/cons_tres: common_init: <span class="hljs-keyword">select</span>/cons_tres loaded
Submitted batch job 4

$ squeue 
JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)
   4     normal    peter     root  R       0:08      2 c[1-2]</code></pre>
<p>and the corresponding output is</p>
<pre><code class="bash hljs">$ <span class="hljs-built_in">cat</span> <span class="hljs-built_in">cat</span> slurm-4.out 
running on c1
1
2
3
4
5
6
7
8
9
10</code></pre>
<p><strong>Question 2</strong>: If the job is run on both nodes, why do we only see <code>c1</code> as output?</p>
<button type="button" class="collapsible" style="background-color:#b5ddff"> Exercise </button><div class="collapsiblecontent">  Now we could also use <code>--cpus-per-task&#61;2</code> to allocate two CPUs.</p>
<p>Try this and explain the result.</p>
<p><div class="solution"> Solution </div><div class="solutioncollapsible">  The following will execute the job with one task but two CPUs</p>
<pre><code class="bash hljs">$ sbatch --cpus-per-task=2 --verbose job.slurm 
sbatch: error: CPU count per node caperformancen not be satisfied
sbatch: error: Batch job submission failed: Requested node configuration is not available</code></pre>
<p>As our testcluster only supports one CPU per node. Slurm is not able to schedule this task and therefore you get the error telling you this. </div> </div>
<p>As we can see it might happen, that our job can not be submitted or that we have an error in the setup.  In order to check if the job is correct we can use the <code>--test-only</code> option</p>
<pre><code class="bash hljs">$ sbatch --test-only job.slurm
sbatch: Job 5 to start at 2023-11-09T17:49:30 using 1 processors on nodes c1 <span class="hljs-keyword">in</span> partition normal

$ sbatch --cpus-per-task=2 --test-only job.slurm
allocation failure: Requested node configuration is not available</code></pre>
<p>On success it will tell us when to job will probably run &#40;to the best of its knowledge&#41; and where.  If it is not successful we see why. </p>
<h3 id="running_parallel_jobs"><a href="#running_parallel_jobs" class="header-anchor">Running parallel jobs</a></h3>
<h2 id="answers_to_the_questions"><a href="#answers_to_the_questions" class="header-anchor">Answers to the questions</a></h2>
<ol>
<li><p>The command <code>sleep 10s &amp;&amp; /bin/hostname</code> first sleeps for 10 seconds, afterwards it will output the node &#40;what we usually see in the prompt&#41; where the job is started.</p>
</li>
<li><p>Our job only runs on one CPU, therefore it only runs on one of the nodes.</p>
</li>
</ol>
<p><table class="fndef" id="fndef:1">
    <tr>
        <td class="fndef-backref"><a href="#fnref:1">[1]</a></td>
        <td class="fndef-content">The standard Operating System is Linux, there are some UNIX clusters but Windows is not the way to go here.</td>
    </tr>
</table>
 <table class="fndef" id="fndef:2">
    <tr>
        <td class="fndef-backref"><a href="#fnref:2">[2]</a></td>
        <td class="fndef-content"><a href="https://www.schedmd.com/index.php">www.schedmd.com</a></td>
    </tr>
</table>
 <table class="fndef" id="fndef:3">
    <tr>
        <td class="fndef-backref"><a href="#fnref:3">[3]</a></td>
        <td class="fndef-content"><a href="https://slurm.schedmd.com/quickstart.html">Quickstart</a> the commands section</td>
    </tr>
</table>
 <table class="fndef" id="fndef:4">
    <tr>
        <td class="fndef-backref"><a href="#fnref:4">[4]</a></td>
        <td class="fndef-content"><a href="https://www.uibk.ac.at/zid/systeme/hpc-systeme/common/tutorials/slurm-tutorial.html">UIBK LEO5 Tutorial</a></td>
    </tr>
</table>
</p>
<div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> - <a href="https://ehrensperger.dev/">Gregor Ehrensperger</a>, <a href="https://orcid.org/0000-0003-3601-0852">Peter Kandolf</a>. Last modified: November 10, 2023.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    </div> <!-- end of class main-content -->
    </div> <!-- end of class main-content-wrap -->
    </div> <!-- end of class page-wrap-->
    
    
      


      <script>
    (function(){
    
      // Get the elements.
      // - the 'pre' element.
      // - the 'div' with the 'paste-content' id.
    
      var pre = document.getElementsByTagName('pre');
    
      // Add a copy button in the 'pre' element.
      // which only has the className of 'language-'.
    
      for (var i = 0; i < pre.length; i++) {
        var isLanguage = pre[i].children[0].tagName == 'CODE';
    
        if ( isLanguage ) {
          var button           = document.createElement('button');
              button.className = 'copy-button';
              button.textContent = 'Copy';
    
              pre[i].appendChild(button);
        }
      };
    
      // Run Clipboard
    
      var copyCode = new Clipboard('.copy-button', {
        target: function(trigger) {
          return trigger.previousElementSibling;
        }
      });
    
      // On success:
      // - Change the "Copy" text to "Copied".
      // - Swap it to "Copy" in 2s.
      // - Lead user to the "contenteditable" area with Velocity scroll.
    
      copyCode.on('success', function(event) {
        event.clearSelection();
        event.trigger.textContent = 'Copied';
        window.setTimeout(function() {
          event.trigger.textContent = 'Copy';
        }, 2000);
    
      });
    
      // On error (Safari):
      // - Change the  "Press Ctrl+C to copy"
      // - Swap it to "Copy" in 2s.
    
      copyCode.on('error', function(event) {
        event.trigger.textContent = 'Press "Ctrl + C" to copy';
        window.setTimeout(function() {
          event.trigger.textContent = 'Copy';
        }, 5000);
      });
    
    })();
</script>
    
  </body>
</html>

<script>
  var coll = document.getElementsByClassName("collapsible");
  var i;

  for (i = 0; i < coll.length; i++) {
    coll[i].addEventListener("click", function() {
      this.classList.toggle("active");
      var content = this.nextElementSibling;
      if (content.style.display === "block") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
    });
  }
</script>

<script>
  var coll = document.getElementsByClassName("solutioncollapsible");
  var sols = document.getElementsByClassName("solution");
  
  const queryString = window.location.search;
  const urlParams = new URLSearchParams(queryString);
  const myVar = urlParams.get('solution')

  if ( myVar == 'true') {
    for (i = 0; i < coll.length; i++) {
      coll[i].style.display = "block";
    }

    for (i = 0; i < sols.length; i++) {
      sols[i].style.display = "block";
    }
  }
</script>