;  @ none:2 within `mySum`
define double @julia_mySum_3783({}* noundef nonnull align 16 dereferenceable(40) %0) #0 {
top:
;  @ none:5 within `mySum`
; ┌ @ abstractarray.jl:314 within `eachindex`
; │┌ @ abstractarray.jl:133 within `axes1`
; ││┌ @ abstractarray.jl:98 within `axes`
; │││┌ @ array.jl:149 within `size`
      %1 = bitcast {}* %0 to { i8*, i64, i16, i16, i32 }*
      %2 = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %1, i64 0, i32 1
      %3 = load i64, i64* %2, align 8
; └└└└
; ┌ @ range.jl:887 within `iterate`
; │┌ @ range.jl:662 within `isempty`
; ││┌ @ operators.jl:369 within `>`
; │││┌ @ int.jl:83 within `<`
      %.not.not = icmp eq i64 %3, 0
; └└└└
  br i1 %.not.not, label %L29, label %L13.preheader

L13.preheader:                                    ; preds = %top
  %4 = bitcast {}* %0 to double**
  %5 = load double*, double** %4, align 8
;  @ none:7 within `mySum`
  br label %L13

L13:                                              ; preds = %L13, %L13.preheader
  %value_phi3 = phi i64 [ %10, %L13 ], [ 1, %L13.preheader ]
  %value_phi5 = phi double [ %9, %L13 ], [ 0.000000e+00, %L13.preheader ]
;  @ none:6 within `mySum`
; ┌ @ essentials.jl:13 within `getindex`
   %6 = add nsw i64 %value_phi3, -1
   %7 = getelementptr inbounds double, double* %5, i64 %6
   %8 = load double, double* %7, align 8
; └
; ┌ @ float.jl:408 within `+`
   %9 = fadd double %value_phi5, %8
; └
;  @ none:7 within `mySum`
; ┌ @ range.jl:891 within `iterate`
; │┌ @ promotion.jl:499 within `==`
    %.not.not12 = icmp eq i64 %value_phi3, %3
; │└
   %10 = add nuw nsw i64 %value_phi3, 1
; └
  br i1 %.not.not12, label %L29, label %L13

L29:                                              ; preds = %L13, %top
  %value_phi9 = phi double [ 0.000000e+00, %top ], [ %9, %L13 ]
;  @ none:9 within `mySum`
  ret double %value_phi9
}

------Separator-------

;  @ none:3 within `mySumSIMD`
define double @julia_mySumSIMD_3792({}* noundef nonnull align 16 dereferenceable(40) %0) #0 {
top:
;  @ none:6 within `mySumSIMD`
; ┌ @ simdloop.jl:69 within `macro expansion`
; │┌ @ abstractarray.jl:314 within `eachindex`
; ││┌ @ abstractarray.jl:133 within `axes1`
; │││┌ @ abstractarray.jl:98 within `axes`
; ││││┌ @ array.jl:149 within `size`
       %1 = bitcast {}* %0 to { i8*, i64, i16, i16, i32 }*
       %2 = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %1, i64 0, i32 1
       %3 = load i64, i64* %2, align 8
; │└└└└
; │ @ simdloop.jl:72 within `macro expansion`
; │┌ @ int.jl:83 within `<`
    %.not = icmp eq i64 %3, 0
; │└
   br i1 %.not, label %L30, label %L13.lr.ph

L13.lr.ph:                                        ; preds = %top
   %4 = bitcast {}* %0 to double**
   %5 = load double*, double** %4, align 8
; │ @ simdloop.jl:75 within `macro expansion`
   %min.iters.check = icmp ult i64 %3, 16
   br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:                                        ; preds = %L13.lr.ph
   %n.vec = and i64 %3, 9223372036854775792
   br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
    %vec.phi = phi <4 x double> [ zeroinitializer, %vector.ph ], [ %14, %vector.body ]
    %vec.phi9 = phi <4 x double> [ zeroinitializer, %vector.ph ], [ %15, %vector.body ]
    %vec.phi10 = phi <4 x double> [ zeroinitializer, %vector.ph ], [ %16, %vector.body ]
    %vec.phi11 = phi <4 x double> [ zeroinitializer, %vector.ph ], [ %17, %vector.body ]
    %6 = getelementptr inbounds double, double* %5, i64 %index
; │└
; │ @ simdloop.jl:77 within `macro expansion` @ none:7
; │┌ @ essentials.jl:13 within `getindex`
    %7 = bitcast double* %6 to <4 x double>*
    %wide.load = load <4 x double>, <4 x double>* %7, align 8
    %8 = getelementptr inbounds double, double* %6, i64 4
    %9 = bitcast double* %8 to <4 x double>*
    %wide.load12 = load <4 x double>, <4 x double>* %9, align 8
    %10 = getelementptr inbounds double, double* %6, i64 8
    %11 = bitcast double* %10 to <4 x double>*
    %wide.load13 = load <4 x double>, <4 x double>* %11, align 8
    %12 = getelementptr inbounds double, double* %6, i64 12
    %13 = bitcast double* %12 to <4 x double>*
    %wide.load14 = load <4 x double>, <4 x double>* %13, align 8
; │└
; │┌ @ float.jl:408 within `+`
    %14 = fadd fast <4 x double> %vec.phi, %wide.load
    %15 = fadd fast <4 x double> %vec.phi9, %wide.load12
    %16 = fadd fast <4 x double> %vec.phi10, %wide.load13
    %17 = fadd fast <4 x double> %vec.phi11, %wide.load14
; │└
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index.next = add nuw i64 %index, 16
    %18 = icmp eq i64 %index.next, %n.vec
    br i1 %18, label %middle.block, label %vector.body

middle.block:                                     ; preds = %vector.body
; │└
; │ @ simdloop.jl:75 within `macro expansion`
   %bin.rdx = fadd fast <4 x double> %15, %14
   %bin.rdx15 = fadd fast <4 x double> %16, %bin.rdx
   %bin.rdx16 = fadd fast <4 x double> %17, %bin.rdx15
   %19 = call fast double @llvm.vector.reduce.fadd.v4f64(double -0.000000e+00, <4 x double> %bin.rdx16)
   %cmp.n = icmp eq i64 %3, %n.vec
   br i1 %cmp.n, label %L30, label %scalar.ph

scalar.ph:                                        ; preds = %middle.block, %L13.lr.ph
   %bc.resume.val = phi i64 [ %n.vec, %middle.block ], [ 0, %L13.lr.ph ]
   %bc.merge.rdx = phi double [ %19, %middle.block ], [ 0.000000e+00, %L13.lr.ph ]
   br label %L13

L13:                                              ; preds = %L13, %scalar.ph
   %value_phi18 = phi i64 [ %bc.resume.val, %scalar.ph ], [ %23, %L13 ]
   %value_phi7 = phi double [ %bc.merge.rdx, %scalar.ph ], [ %22, %L13 ]
; │ @ simdloop.jl:77 within `macro expansion` @ none:7
; │┌ @ essentials.jl:13 within `getindex`
    %20 = getelementptr inbounds double, double* %5, i64 %value_phi18
    %21 = load double, double* %20, align 8
; │└
; │┌ @ float.jl:408 within `+`
    %22 = fadd fast double %value_phi7, %21
; │└
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %23 = add nuw nsw i64 %value_phi18, 1
; │└
; │ @ simdloop.jl:75 within `macro expansion`
; │┌ @ int.jl:83 within `<`
    %exitcond.not = icmp eq i64 %23, %3
; │└
   br i1 %exitcond.not, label %L30, label %L13

L30:                                              ; preds = %L13, %middle.block, %top
   %value_phi2 = phi double [ 0.000000e+00, %top ], [ %19, %middle.block ], [ %22, %L13 ]
; └
;  @ none:10 within `mySumSIMD`
  ret double %value_phi2
}
