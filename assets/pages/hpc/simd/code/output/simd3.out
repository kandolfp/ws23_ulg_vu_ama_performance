;  @ none:1 within `my_sum`
define double @julia_my_sum_1940({}* noundef nonnull align 16 dereferenceable(40) %0) #0 {
top:
;  @ none:4 within `my_sum`
; ┌ @ abstractarray.jl:318 within `eachindex`
; │┌ @ abstractarray.jl:134 within `axes1`
; ││┌ @ abstractarray.jl:98 within `axes`
; │││┌ @ array.jl:191 within `size`
      %1 = bitcast {}* %0 to { i8*, i64, i16, i16, i32 }*
      %arraylen_ptr = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %1, i64 0, i32 1
      %arraylen = load i64, i64* %arraylen_ptr, align 8
; └└└└
; ┌ @ range.jl:897 within `iterate`
; │┌ @ range.jl:672 within `isempty`
; ││┌ @ operators.jl:378 within `>`
; │││┌ @ int.jl:83 within `<`
      %.not.not = icmp eq i64 %arraylen, 0
; └└└└
  br i1 %.not.not, label %L29, label %L13.preheader

L13.preheader:                                    ; preds = %top
  %2 = bitcast {}* %0 to double**
  %arrayptr12 = load double*, double** %2, align 8
;  @ none:6 within `my_sum`
  %3 = add nsw i64 %arraylen, -1
  %xtraiter = and i64 %arraylen, 7
  %4 = icmp ult i64 %3, 7
  br i1 %4, label %L29.loopexit.unr-lcssa, label %L13.preheader.new

L13.preheader.new:                                ; preds = %L13.preheader
  %unroll_iter = and i64 %arraylen, 9223372036854775800
  br label %L13

L13:                                              ; preds = %L13, %L13.preheader.new
  %value_phi3 = phi i64 [ 1, %L13.preheader.new ], [ %28, %L13 ]
  %value_phi5 = phi double [ 0.000000e+00, %L13.preheader.new ], [ %27, %L13 ]
  %niter = phi i64 [ 0, %L13.preheader.new ], [ %niter.next.7, %L13 ]
;  @ none:5 within `my_sum`
; ┌ @ essentials.jl:13 within `getindex`
   %5 = add nsw i64 %value_phi3, -1
   %6 = getelementptr inbounds double, double* %arrayptr12, i64 %5
   %arrayref = load double, double* %6, align 8
; └
; ┌ @ float.jl:409 within `+`
   %7 = fadd double %value_phi5, %arrayref
; └
;  @ none:6 within `my_sum`
; ┌ @ range.jl:901 within `iterate`
   %8 = add nuw nsw i64 %value_phi3, 1
; └
;  @ none:5 within `my_sum`
; ┌ @ essentials.jl:13 within `getindex`
   %9 = getelementptr inbounds double, double* %arrayptr12, i64 %value_phi3
   %arrayref.1 = load double, double* %9, align 8
; └
; ┌ @ float.jl:409 within `+`
   %10 = fadd double %7, %arrayref.1
; └
;  @ none:6 within `my_sum`
; ┌ @ range.jl:901 within `iterate`
   %11 = add nuw nsw i64 %value_phi3, 2
; └
;  @ none:5 within `my_sum`
; ┌ @ essentials.jl:13 within `getindex`
   %12 = getelementptr inbounds double, double* %arrayptr12, i64 %8
   %arrayref.2 = load double, double* %12, align 8
; └
; ┌ @ float.jl:409 within `+`
   %13 = fadd double %10, %arrayref.2
; └
;  @ none:6 within `my_sum`
; ┌ @ range.jl:901 within `iterate`
   %14 = add nuw nsw i64 %value_phi3, 3
; └
;  @ none:5 within `my_sum`
; ┌ @ essentials.jl:13 within `getindex`
   %15 = getelementptr inbounds double, double* %arrayptr12, i64 %11
   %arrayref.3 = load double, double* %15, align 8
; └
; ┌ @ float.jl:409 within `+`
   %16 = fadd double %13, %arrayref.3
; └
;  @ none:6 within `my_sum`
; ┌ @ range.jl:901 within `iterate`
   %17 = add nuw nsw i64 %value_phi3, 4
; └
;  @ none:5 within `my_sum`
; ┌ @ essentials.jl:13 within `getindex`
   %18 = getelementptr inbounds double, double* %arrayptr12, i64 %14
   %arrayref.4 = load double, double* %18, align 8
; └
; ┌ @ float.jl:409 within `+`
   %19 = fadd double %16, %arrayref.4
; └
;  @ none:6 within `my_sum`
; ┌ @ range.jl:901 within `iterate`
   %20 = add nuw nsw i64 %value_phi3, 5
; └
;  @ none:5 within `my_sum`
; ┌ @ essentials.jl:13 within `getindex`
   %21 = getelementptr inbounds double, double* %arrayptr12, i64 %17
   %arrayref.5 = load double, double* %21, align 8
; └
; ┌ @ float.jl:409 within `+`
   %22 = fadd double %19, %arrayref.5
; └
;  @ none:6 within `my_sum`
; ┌ @ range.jl:901 within `iterate`
   %23 = add nuw nsw i64 %value_phi3, 6
; └
;  @ none:5 within `my_sum`
; ┌ @ essentials.jl:13 within `getindex`
   %24 = getelementptr inbounds double, double* %arrayptr12, i64 %20
   %arrayref.6 = load double, double* %24, align 8
; └
; ┌ @ float.jl:409 within `+`
   %25 = fadd double %22, %arrayref.6
; └
; ┌ @ essentials.jl:13 within `getindex`
   %26 = getelementptr inbounds double, double* %arrayptr12, i64 %23
   %arrayref.7 = load double, double* %26, align 8
; └
; ┌ @ float.jl:409 within `+`
   %27 = fadd double %25, %arrayref.7
; └
;  @ none:6 within `my_sum`
; ┌ @ range.jl:901 within `iterate`
   %28 = add nuw nsw i64 %value_phi3, 8
; └
  %niter.next.7 = add i64 %niter, 8
  %niter.ncmp.7 = icmp eq i64 %niter.next.7, %unroll_iter
  br i1 %niter.ncmp.7, label %L29.loopexit.unr-lcssa, label %L13

L29.loopexit.unr-lcssa:                           ; preds = %L13, %L13.preheader
  %.lcssa.ph = phi double [ undef, %L13.preheader ], [ %27, %L13 ]
  %value_phi3.unr = phi i64 [ 1, %L13.preheader ], [ %28, %L13 ]
  %value_phi5.unr = phi double [ 0.000000e+00, %L13.preheader ], [ %27, %L13 ]
  %lcmp.mod.not = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod.not, label %L29, label %L13.epil

L13.epil:                                         ; preds = %L13.epil, %L29.loopexit.unr-lcssa
  %value_phi3.epil = phi i64 [ %32, %L13.epil ], [ %value_phi3.unr, %L29.loopexit.unr-lcssa ]
  %value_phi5.epil = phi double [ %31, %L13.epil ], [ %value_phi5.unr, %L29.loopexit.unr-lcssa ]
  %epil.iter = phi i64 [ %epil.iter.next, %L13.epil ], [ 0, %L29.loopexit.unr-lcssa ]
;  @ none:5 within `my_sum`
; ┌ @ essentials.jl:13 within `getindex`
   %29 = add nsw i64 %value_phi3.epil, -1
   %30 = getelementptr inbounds double, double* %arrayptr12, i64 %29
   %arrayref.epil = load double, double* %30, align 8
; └
; ┌ @ float.jl:409 within `+`
   %31 = fadd double %value_phi5.epil, %arrayref.epil
; └
;  @ none:6 within `my_sum`
; ┌ @ range.jl:901 within `iterate`
   %32 = add nuw nsw i64 %value_phi3.epil, 1
; └
  %epil.iter.next = add i64 %epil.iter, 1
  %epil.iter.cmp.not = icmp eq i64 %epil.iter.next, %xtraiter
  br i1 %epil.iter.cmp.not, label %L29, label %L13.epil

L29:                                              ; preds = %L13.epil, %L29.loopexit.unr-lcssa, %top
  %value_phi9 = phi double [ 0.000000e+00, %top ], [ %.lcssa.ph, %L29.loopexit.unr-lcssa ], [ %31, %L13.epil ]
;  @ none:8 within `my_sum`
  ret double %value_phi9
}

------Separator-------

;  @ none:1 within `my_sum_simd`
define double @julia_my_sum_simd_1942({}* noundef nonnull align 16 dereferenceable(40) %0) #0 {
top:
;  @ none:4 within `my_sum_simd`
; ┌ @ simdloop.jl:69 within `macro expansion`
; │┌ @ abstractarray.jl:318 within `eachindex`
; ││┌ @ abstractarray.jl:134 within `axes1`
; │││┌ @ abstractarray.jl:98 within `axes`
; ││││┌ @ array.jl:191 within `size`
       %1 = bitcast {}* %0 to { i8*, i64, i16, i16, i32 }*
       %arraylen_ptr = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %1, i64 0, i32 1
       %arraylen = load i64, i64* %arraylen_ptr, align 8
; │└└└└
; │ @ simdloop.jl:72 within `macro expansion`
; │┌ @ int.jl:83 within `<`
    %.not = icmp eq i64 %arraylen, 0
; │└
   br i1 %.not, label %L30, label %L13.lr.ph

L13.lr.ph:                                        ; preds = %top
   %2 = bitcast {}* %0 to double**
   %arrayptr6 = load double*, double** %2, align 8
; │ @ simdloop.jl:75 within `macro expansion`
   %min.iters.check = icmp ult i64 %arraylen, 16
   br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:                                        ; preds = %L13.lr.ph
   %n.vec = and i64 %arraylen, 9223372036854775792
   %3 = add nsw i64 %n.vec, -16
   %4 = lshr exact i64 %3, 4
   %5 = add nuw nsw i64 %4, 1
   %xtraiter = and i64 %5, 7
   %6 = icmp ult i64 %3, 112
   br i1 %6, label %middle.block.unr-lcssa, label %vector.ph.new

vector.ph.new:                                    ; preds = %vector.ph
   %unroll_iter = and i64 %5, 2305843009213693944
   br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph.new
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index = phi i64 [ 0, %vector.ph.new ], [ %index.next.7, %vector.body ]
    %vec.phi = phi <4 x double> [ <double 0.000000e+00, double -0.000000e+00, double -0.000000e+00, double -0.000000e+00>, %vector.ph.new ], [ %99, %vector.body ]
    %vec.phi10 = phi <4 x double> [ <double -0.000000e+00, double -0.000000e+00, double -0.000000e+00, double -0.000000e+00>, %vector.ph.new ], [ %100, %vector.body ]
    %vec.phi11 = phi <4 x double> [ <double -0.000000e+00, double -0.000000e+00, double -0.000000e+00, double -0.000000e+00>, %vector.ph.new ], [ %101, %vector.body ]
    %vec.phi12 = phi <4 x double> [ <double -0.000000e+00, double -0.000000e+00, double -0.000000e+00, double -0.000000e+00>, %vector.ph.new ], [ %102, %vector.body ]
    %niter = phi i64 [ 0, %vector.ph.new ], [ %niter.next.7, %vector.body ]
; │└
; │ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ essentials.jl:13 within `getindex`
    %7 = getelementptr inbounds double, double* %arrayptr6, i64 %index
    %8 = bitcast double* %7 to <4 x double>*
    %wide.load = load <4 x double>, <4 x double>* %8, align 8
    %9 = getelementptr inbounds double, double* %7, i64 4
    %10 = bitcast double* %9 to <4 x double>*
    %wide.load13 = load <4 x double>, <4 x double>* %10, align 8
    %11 = getelementptr inbounds double, double* %7, i64 8
    %12 = bitcast double* %11 to <4 x double>*
    %wide.load14 = load <4 x double>, <4 x double>* %12, align 8
    %13 = getelementptr inbounds double, double* %7, i64 12
    %14 = bitcast double* %13 to <4 x double>*
    %wide.load15 = load <4 x double>, <4 x double>* %14, align 8
; │└
; │┌ @ float.jl:409 within `+`
    %15 = fadd reassoc contract <4 x double> %vec.phi, %wide.load
    %16 = fadd reassoc contract <4 x double> %vec.phi10, %wide.load13
    %17 = fadd reassoc contract <4 x double> %vec.phi11, %wide.load14
    %18 = fadd reassoc contract <4 x double> %vec.phi12, %wide.load15
; │└
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index.next = or i64 %index, 16
; │└
; │ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ essentials.jl:13 within `getindex`
    %19 = getelementptr inbounds double, double* %arrayptr6, i64 %index.next
    %20 = bitcast double* %19 to <4 x double>*
    %wide.load.1 = load <4 x double>, <4 x double>* %20, align 8
    %21 = getelementptr inbounds double, double* %19, i64 4
    %22 = bitcast double* %21 to <4 x double>*
    %wide.load13.1 = load <4 x double>, <4 x double>* %22, align 8
    %23 = getelementptr inbounds double, double* %19, i64 8
    %24 = bitcast double* %23 to <4 x double>*
    %wide.load14.1 = load <4 x double>, <4 x double>* %24, align 8
    %25 = getelementptr inbounds double, double* %19, i64 12
    %26 = bitcast double* %25 to <4 x double>*
    %wide.load15.1 = load <4 x double>, <4 x double>* %26, align 8
; │└
; │┌ @ float.jl:409 within `+`
    %27 = fadd reassoc contract <4 x double> %15, %wide.load.1
    %28 = fadd reassoc contract <4 x double> %16, %wide.load13.1
    %29 = fadd reassoc contract <4 x double> %17, %wide.load14.1
    %30 = fadd reassoc contract <4 x double> %18, %wide.load15.1
; │└
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index.next.1 = or i64 %index, 32
; │└
; │ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ essentials.jl:13 within `getindex`
    %31 = getelementptr inbounds double, double* %arrayptr6, i64 %index.next.1
    %32 = bitcast double* %31 to <4 x double>*
    %wide.load.2 = load <4 x double>, <4 x double>* %32, align 8
    %33 = getelementptr inbounds double, double* %31, i64 4
    %34 = bitcast double* %33 to <4 x double>*
    %wide.load13.2 = load <4 x double>, <4 x double>* %34, align 8
    %35 = getelementptr inbounds double, double* %31, i64 8
    %36 = bitcast double* %35 to <4 x double>*
    %wide.load14.2 = load <4 x double>, <4 x double>* %36, align 8
    %37 = getelementptr inbounds double, double* %31, i64 12
    %38 = bitcast double* %37 to <4 x double>*
    %wide.load15.2 = load <4 x double>, <4 x double>* %38, align 8
; │└
; │┌ @ float.jl:409 within `+`
    %39 = fadd reassoc contract <4 x double> %27, %wide.load.2
    %40 = fadd reassoc contract <4 x double> %28, %wide.load13.2
    %41 = fadd reassoc contract <4 x double> %29, %wide.load14.2
    %42 = fadd reassoc contract <4 x double> %30, %wide.load15.2
; │└
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index.next.2 = or i64 %index, 48
; │└
; │ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ essentials.jl:13 within `getindex`
    %43 = getelementptr inbounds double, double* %arrayptr6, i64 %index.next.2
    %44 = bitcast double* %43 to <4 x double>*
    %wide.load.3 = load <4 x double>, <4 x double>* %44, align 8
    %45 = getelementptr inbounds double, double* %43, i64 4
    %46 = bitcast double* %45 to <4 x double>*
    %wide.load13.3 = load <4 x double>, <4 x double>* %46, align 8
    %47 = getelementptr inbounds double, double* %43, i64 8
    %48 = bitcast double* %47 to <4 x double>*
    %wide.load14.3 = load <4 x double>, <4 x double>* %48, align 8
    %49 = getelementptr inbounds double, double* %43, i64 12
    %50 = bitcast double* %49 to <4 x double>*
    %wide.load15.3 = load <4 x double>, <4 x double>* %50, align 8
; │└
; │┌ @ float.jl:409 within `+`
    %51 = fadd reassoc contract <4 x double> %39, %wide.load.3
    %52 = fadd reassoc contract <4 x double> %40, %wide.load13.3
    %53 = fadd reassoc contract <4 x double> %41, %wide.load14.3
    %54 = fadd reassoc contract <4 x double> %42, %wide.load15.3
; │└
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index.next.3 = or i64 %index, 64
; │└
; │ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ essentials.jl:13 within `getindex`
    %55 = getelementptr inbounds double, double* %arrayptr6, i64 %index.next.3
    %56 = bitcast double* %55 to <4 x double>*
    %wide.load.4 = load <4 x double>, <4 x double>* %56, align 8
    %57 = getelementptr inbounds double, double* %55, i64 4
    %58 = bitcast double* %57 to <4 x double>*
    %wide.load13.4 = load <4 x double>, <4 x double>* %58, align 8
    %59 = getelementptr inbounds double, double* %55, i64 8
    %60 = bitcast double* %59 to <4 x double>*
    %wide.load14.4 = load <4 x double>, <4 x double>* %60, align 8
    %61 = getelementptr inbounds double, double* %55, i64 12
    %62 = bitcast double* %61 to <4 x double>*
    %wide.load15.4 = load <4 x double>, <4 x double>* %62, align 8
; │└
; │┌ @ float.jl:409 within `+`
    %63 = fadd reassoc contract <4 x double> %51, %wide.load.4
    %64 = fadd reassoc contract <4 x double> %52, %wide.load13.4
    %65 = fadd reassoc contract <4 x double> %53, %wide.load14.4
    %66 = fadd reassoc contract <4 x double> %54, %wide.load15.4
; │└
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index.next.4 = or i64 %index, 80
; │└
; │ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ essentials.jl:13 within `getindex`
    %67 = getelementptr inbounds double, double* %arrayptr6, i64 %index.next.4
    %68 = bitcast double* %67 to <4 x double>*
    %wide.load.5 = load <4 x double>, <4 x double>* %68, align 8
    %69 = getelementptr inbounds double, double* %67, i64 4
    %70 = bitcast double* %69 to <4 x double>*
    %wide.load13.5 = load <4 x double>, <4 x double>* %70, align 8
    %71 = getelementptr inbounds double, double* %67, i64 8
    %72 = bitcast double* %71 to <4 x double>*
    %wide.load14.5 = load <4 x double>, <4 x double>* %72, align 8
    %73 = getelementptr inbounds double, double* %67, i64 12
    %74 = bitcast double* %73 to <4 x double>*
    %wide.load15.5 = load <4 x double>, <4 x double>* %74, align 8
; │└
; │┌ @ float.jl:409 within `+`
    %75 = fadd reassoc contract <4 x double> %63, %wide.load.5
    %76 = fadd reassoc contract <4 x double> %64, %wide.load13.5
    %77 = fadd reassoc contract <4 x double> %65, %wide.load14.5
    %78 = fadd reassoc contract <4 x double> %66, %wide.load15.5
; │└
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index.next.5 = or i64 %index, 96
; │└
; │ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ essentials.jl:13 within `getindex`
    %79 = getelementptr inbounds double, double* %arrayptr6, i64 %index.next.5
    %80 = bitcast double* %79 to <4 x double>*
    %wide.load.6 = load <4 x double>, <4 x double>* %80, align 8
    %81 = getelementptr inbounds double, double* %79, i64 4
    %82 = bitcast double* %81 to <4 x double>*
    %wide.load13.6 = load <4 x double>, <4 x double>* %82, align 8
    %83 = getelementptr inbounds double, double* %79, i64 8
    %84 = bitcast double* %83 to <4 x double>*
    %wide.load14.6 = load <4 x double>, <4 x double>* %84, align 8
    %85 = getelementptr inbounds double, double* %79, i64 12
    %86 = bitcast double* %85 to <4 x double>*
    %wide.load15.6 = load <4 x double>, <4 x double>* %86, align 8
; │└
; │┌ @ float.jl:409 within `+`
    %87 = fadd reassoc contract <4 x double> %75, %wide.load.6
    %88 = fadd reassoc contract <4 x double> %76, %wide.load13.6
    %89 = fadd reassoc contract <4 x double> %77, %wide.load14.6
    %90 = fadd reassoc contract <4 x double> %78, %wide.load15.6
; │└
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index.next.6 = or i64 %index, 112
; │└
; │ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ essentials.jl:13 within `getindex`
    %91 = getelementptr inbounds double, double* %arrayptr6, i64 %index.next.6
    %92 = bitcast double* %91 to <4 x double>*
    %wide.load.7 = load <4 x double>, <4 x double>* %92, align 8
    %93 = getelementptr inbounds double, double* %91, i64 4
    %94 = bitcast double* %93 to <4 x double>*
    %wide.load13.7 = load <4 x double>, <4 x double>* %94, align 8
    %95 = getelementptr inbounds double, double* %91, i64 8
    %96 = bitcast double* %95 to <4 x double>*
    %wide.load14.7 = load <4 x double>, <4 x double>* %96, align 8
    %97 = getelementptr inbounds double, double* %91, i64 12
    %98 = bitcast double* %97 to <4 x double>*
    %wide.load15.7 = load <4 x double>, <4 x double>* %98, align 8
; │└
; │┌ @ float.jl:409 within `+`
    %99 = fadd reassoc contract <4 x double> %87, %wide.load.7
    %100 = fadd reassoc contract <4 x double> %88, %wide.load13.7
    %101 = fadd reassoc contract <4 x double> %89, %wide.load14.7
    %102 = fadd reassoc contract <4 x double> %90, %wide.load15.7
; │└
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index.next.7 = add nuw i64 %index, 128
    %niter.next.7 = add i64 %niter, 8
    %niter.ncmp.7 = icmp eq i64 %niter.next.7, %unroll_iter
    br i1 %niter.ncmp.7, label %middle.block.unr-lcssa, label %vector.body

middle.block.unr-lcssa:                           ; preds = %vector.body, %vector.ph
    %.lcssa21.ph = phi <4 x double> [ undef, %vector.ph ], [ %99, %vector.body ]
    %.lcssa20.ph = phi <4 x double> [ undef, %vector.ph ], [ %100, %vector.body ]
    %.lcssa19.ph = phi <4 x double> [ undef, %vector.ph ], [ %101, %vector.body ]
    %.lcssa18.ph = phi <4 x double> [ undef, %vector.ph ], [ %102, %vector.body ]
    %index.unr = phi i64 [ 0, %vector.ph ], [ %index.next.7, %vector.body ]
    %vec.phi.unr = phi <4 x double> [ <double 0.000000e+00, double -0.000000e+00, double -0.000000e+00, double -0.000000e+00>, %vector.ph ], [ %99, %vector.body ]
    %vec.phi10.unr = phi <4 x double> [ <double -0.000000e+00, double -0.000000e+00, double -0.000000e+00, double -0.000000e+00>, %vector.ph ], [ %100, %vector.body ]
    %vec.phi11.unr = phi <4 x double> [ <double -0.000000e+00, double -0.000000e+00, double -0.000000e+00, double -0.000000e+00>, %vector.ph ], [ %101, %vector.body ]
    %vec.phi12.unr = phi <4 x double> [ <double -0.000000e+00, double -0.000000e+00, double -0.000000e+00, double -0.000000e+00>, %vector.ph ], [ %102, %vector.body ]
    %lcmp.mod.not = icmp eq i64 %xtraiter, 0
    br i1 %lcmp.mod.not, label %middle.block, label %vector.body.epil

vector.body.epil:                                 ; preds = %vector.body.epil, %middle.block.unr-lcssa
    %index.epil = phi i64 [ %index.next.epil, %vector.body.epil ], [ %index.unr, %middle.block.unr-lcssa ]
    %vec.phi.epil = phi <4 x double> [ %111, %vector.body.epil ], [ %vec.phi.unr, %middle.block.unr-lcssa ]
    %vec.phi10.epil = phi <4 x double> [ %112, %vector.body.epil ], [ %vec.phi10.unr, %middle.block.unr-lcssa ]
    %vec.phi11.epil = phi <4 x double> [ %113, %vector.body.epil ], [ %vec.phi11.unr, %middle.block.unr-lcssa ]
    %vec.phi12.epil = phi <4 x double> [ %114, %vector.body.epil ], [ %vec.phi12.unr, %middle.block.unr-lcssa ]
    %epil.iter = phi i64 [ %epil.iter.next, %vector.body.epil ], [ 0, %middle.block.unr-lcssa ]
; │└
; │ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ essentials.jl:13 within `getindex`
    %103 = getelementptr inbounds double, double* %arrayptr6, i64 %index.epil
    %104 = bitcast double* %103 to <4 x double>*
    %wide.load.epil = load <4 x double>, <4 x double>* %104, align 8
    %105 = getelementptr inbounds double, double* %103, i64 4
    %106 = bitcast double* %105 to <4 x double>*
    %wide.load13.epil = load <4 x double>, <4 x double>* %106, align 8
    %107 = getelementptr inbounds double, double* %103, i64 8
    %108 = bitcast double* %107 to <4 x double>*
    %wide.load14.epil = load <4 x double>, <4 x double>* %108, align 8
    %109 = getelementptr inbounds double, double* %103, i64 12
    %110 = bitcast double* %109 to <4 x double>*
    %wide.load15.epil = load <4 x double>, <4 x double>* %110, align 8
; │└
; │┌ @ float.jl:409 within `+`
    %111 = fadd reassoc contract <4 x double> %vec.phi.epil, %wide.load.epil
    %112 = fadd reassoc contract <4 x double> %vec.phi10.epil, %wide.load13.epil
    %113 = fadd reassoc contract <4 x double> %vec.phi11.epil, %wide.load14.epil
    %114 = fadd reassoc contract <4 x double> %vec.phi12.epil, %wide.load15.epil
; │└
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index.next.epil = add nuw i64 %index.epil, 16
    %epil.iter.next = add i64 %epil.iter, 1
    %epil.iter.cmp.not = icmp eq i64 %epil.iter.next, %xtraiter
    br i1 %epil.iter.cmp.not, label %middle.block, label %vector.body.epil

middle.block:                                     ; preds = %vector.body.epil, %middle.block.unr-lcssa
; │└
; │ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ float.jl:409 within `+`
    %.lcssa21 = phi <4 x double> [ %.lcssa21.ph, %middle.block.unr-lcssa ], [ %111, %vector.body.epil ]
    %.lcssa20 = phi <4 x double> [ %.lcssa20.ph, %middle.block.unr-lcssa ], [ %112, %vector.body.epil ]
    %.lcssa19 = phi <4 x double> [ %.lcssa19.ph, %middle.block.unr-lcssa ], [ %113, %vector.body.epil ]
    %.lcssa18 = phi <4 x double> [ %.lcssa18.ph, %middle.block.unr-lcssa ], [ %114, %vector.body.epil ]
; │└
; │ @ simdloop.jl:75 within `macro expansion`
   %bin.rdx = fadd reassoc contract <4 x double> %.lcssa20, %.lcssa21
   %bin.rdx16 = fadd reassoc contract <4 x double> %.lcssa19, %bin.rdx
   %bin.rdx17 = fadd reassoc contract <4 x double> %.lcssa18, %bin.rdx16
   %115 = call reassoc contract double @llvm.vector.reduce.fadd.v4f64(double -0.000000e+00, <4 x double> %bin.rdx17)
   %cmp.n = icmp eq i64 %arraylen, %n.vec
   br i1 %cmp.n, label %L30, label %scalar.ph

scalar.ph:                                        ; preds = %middle.block, %L13.lr.ph
   %bc.resume.val = phi i64 [ %n.vec, %middle.block ], [ 0, %L13.lr.ph ]
   %bc.merge.rdx = phi double [ %115, %middle.block ], [ 0.000000e+00, %L13.lr.ph ]
   br label %L13

L13:                                              ; preds = %L13, %scalar.ph
   %value_phi19 = phi i64 [ %bc.resume.val, %scalar.ph ], [ %118, %L13 ]
   %value_phi8 = phi double [ %bc.merge.rdx, %scalar.ph ], [ %117, %L13 ]
; │ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ essentials.jl:13 within `getindex`
    %116 = getelementptr inbounds double, double* %arrayptr6, i64 %value_phi19
    %arrayref = load double, double* %116, align 8
; │└
; │┌ @ float.jl:409 within `+`
    %117 = fadd reassoc contract double %value_phi8, %arrayref
; │└
; │ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %118 = add nuw nsw i64 %value_phi19, 1
; │└
; │ @ simdloop.jl:75 within `macro expansion`
; │┌ @ int.jl:83 within `<`
    %exitcond.not = icmp eq i64 %118, %arraylen
; │└
   br i1 %exitcond.not, label %L30, label %L13

L30:                                              ; preds = %L13, %middle.block, %top
   %value_phi2 = phi double [ 0.000000e+00, %top ], [ %115, %middle.block ], [ %117, %L13 ]
; └
;  @ none:8 within `my_sum_simd`
  ret double %value_phi2
}
